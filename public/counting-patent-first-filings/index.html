<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.32.2" />


<title>Counting Patent First Filings the Tidy Way with R - Paul Oldham&#39;s Blog</title>
<meta property="og:title" content="Counting Patent First Filings the Tidy Way with R - Paul Oldham&#39;s Blog">
<meta property="og:type" content="article">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="https://www.pauloldham.net/images/paul-oval.png" >
  


<meta property="description" content="For accurate patent statistics you need to be able to identify the earliest priority filings. This article shows you how with R as part of work for the WIPO Patent Analytics Handbook.">
<meta property="og:description" content="For accurate patent statistics you need to be able to identify the earliest priority filings. This article shows you how with R as part of work for the WIPO Patent Analytics Handbook.">



<meta name="twitter:creator" content="@junglepaul">
<meta name="twitter:site" content="">


  
  <meta property="description" content="For accurate patent statistics you need to be able to identify the earliest priority filings. This article shows you how with R as part of work for the WIPO Patent Analytics Handbook.">
  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/paul-oval.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="https://twitter.com/junglepaul">@junglepaul</a></li>
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/poldham">GitHub</a></li>
    
    <li><a href="https://github.com/wipo-analytics">WIPO Analytics</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">38 min read</span>
    

    <h1 class="article-title">Counting Patent First Filings the Tidy Way with R</h1>

    
    <span class="article-date">2018/05/11</span>
    

    <div class="article-content">
      <p>This article provides an in depth introduction to counting patent first filings or priority counts. It is a work in progress chapter for the WIPO Patent Analytics Handbook focusing on advanced patent analytics and builds on the introductory <a href="https://wipo-analytics.github.io/">WIPO Manual on Open Source Patent Analytics</a>.</p>
<p>Counting first filings is an important subject for patent statistics because the first filing of a patent application marks the date that is closest to investment in research and development leading to the invention. For this reason it is widely used by economists and statisticians as a proxy indicator for the analysis of trends in science and technology.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> For patent applicants, the first filing, and the priority date that defines it, can be the difference between success and failure. An applicant with priority in the filing of an application for the same invention as their competitor will win in a dispute, and potentially win in multiple countries around the world. Millions, and in some cases hundreds of millions, of dollars may ride on who holds priority over an invention.</p>
<p>For such an important subject, remarkably little has been written on the practical aspects of counting patents by priority or, as is more intuitive, first filings. The international patent priority system has its origins in the <a href="http://www.wipo.int/treaties/en/ip/paris/summary_paris.html">1883 Paris Convention for the Protection of Industrial Property</a> and basically means that inventors in contracting states to the Convention have a twelve month period from the date of filing their invention to file in other contracting states. During that period any filing in a contracting state will be treated as if it was filed on the same date as the original filing and will enjoy priority over other competing claims to the same invention.</p>
<p>The best existing guide to understanding priority counts is the 2009 <a href="http://www.oecd.org/sti/inno/oecdpatentstatisticsmanual.htm">OECD Patent Statistics Manual</a>. The <a href="http://www.oecd.org/sti/inno/oecdpatentstatisticsmanual.htm">OECD Patent Statistics Manual</a> is an excellent resource but does not focus on practical demonstration. This article focuses on the practical issues involved in counting by priority.</p>
<p>By the end of this article you will have an understanding of what priority numbers are and how to use them to generate descriptive patent statistics. You will also be aware of the challenges involved in using priority counts and how to address them.</p>
<p>We will use R inside RStudio because it provides much more flexibility than tools such as Excel. If you are new to R follow the instructions below on installing R and RStudio. If you are familiar with R but new to patent data, welcome to the challenge. We will use a tidy approach to working with the data and the <code>tidyverse</code> suite of packages. This allows us to write code that is easy to read and to be transparent about the steps we are taking.</p>
<div id="installing-r-and-rstudio" class="section level3">
<h3>Installing R and RStudio</h3>
<p>To install R for your operating system choose the appropriate option <a href="http://cran.rstudio.com/">here</a> and install R. Then download the free RStudio desktop for your system <a href="https://www.rstudio.com/products/rstudio/download/#download">here</a>. We will be using a suite of packages called the <code>tidyverse</code> that make it easy to work with data. When you have installed and opened RStudio run this line in your console.</p>
<pre class="r"><code>install.packages(&quot;tidyverse&quot;)</code></pre>
<p>Next load the library</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<p>You will now see a bunch of messages as the packages are loaded. You should now be good to go.</p>
<p>If you would like to learn more about R then try the excellent <a href="http://www.wipo.int/treaties/en/ip/paris/summary_paris.html">DataCamp</a> online courses or read Garrett Grolemund and Hadley Wickham’s <a href="http://r4ds.had.co.nz/">R for Data Science</a>. Learning to do things in R will make a huge difference to your ability to work with patent and other data and to enjoy the support of the R community in addressing new challenges. There is never a better time to start learning to do things in R than right now.</p>
</div>
<div id="the-drones-dataset" class="section level3">
<h3>The Drones Dataset</h3>
<p>The drones dataset consists of 18,970 patent publications that contain the words drone or drones somewhere in the text. The dataset is based on a search of the full text patent collections of the United States, the European Patent Office (covering members of the European Patent Convention), the Japan Patent Office, and the Patent Cooperation Treaty (WO) administered by the World Intellectual Property Organisation. The data is based on a search of the commercial <a href="https://clarivate.com/products/derwent-innovation/">Clarivate Analytics Derwent Innovations</a> database which makes it easy to search and download full text data at scales up to 60,000 records at a time.</p>
<p>We will be working with the drones <code>numbers</code> set that is confined to just patent numbers in their raw form as downloaded from Derwent Innovation. You can download the dataset <a href="https://github.com/wipo-analytics/drones_data/blob/master/numbers.csv?raw=true">here</a> or import it directly by running the following in your RStudio console.</p>
<pre class="r"><code>library(tidyverse)
numbers &lt;- read_csv(&quot;https://github.com/wipo-analytics/drones_data/blob/master/numbers.csv?raw=true&quot;)</code></pre>
</div>
<div id="the-priority-number" class="section level3">
<h3>The priority number</h3>
<p>In the table below we can see that we have a dataset consisting of five columns starting with the priority number.</p>
<pre class="r"><code>numbers</code></pre>
<pre><code>## # A tibble: 18,970 x 5
##    priority_number                                                                                                                                                                        application_number  family_first family_number publication_num…
##    &lt;chr&gt;                                                                                                                                                                                  &lt;chr&gt;               &lt;chr&gt;        &lt;chr&gt;         &lt;chr&gt;           
##  1 US2016578323F 2016-09-20                                                                                                                                                               US2016578323F 2016… &lt;NA&gt;         &lt;NA&gt;          USD801224S1     
##  2 US14954632A 2015-11-30                                                                                                                                                                 US14954632A 2015-1… &lt;NA&gt;         &lt;NA&gt;          US9807866B2     
##  3 US15360203A 2016-11-23                                                                                                                                                                 US15360203A 2016-1… &lt;NA&gt;         &lt;NA&gt;          US9807726B1     
##  4 US62203383P 2015-08-10; US62314047P 2016-03-28                                                                                                                                         US15454805A 2017-0… &lt;NA&gt;         &lt;NA&gt;          US9807625B2     
##  5 US62200764P 2015-08-04; US62314042P 2016-03-28                                                                                                                                         US15263985A 2016-0… &lt;NA&gt;         &lt;NA&gt;          US9807619B2     
##  6 KR201528901A 2015-03-02                                                                                                                                                                US15057264A 2016-0… &lt;NA&gt;         &lt;NA&gt;          US9807364B2     
##  7 US15217944A 2016-07-22; US2015196885P 2015-07-24; US62196885P 2015-07-24                                                                                                               US15217944A 2016-0… &lt;NA&gt;         &lt;NA&gt;          US9806846B2     
##  8 US2008100721P 2008-09-27; US2008108743P 2008-10-27; US2008121159P 2008-12-09; US2009142796P 2009-01-06; US2009142818P 2009-01-06; US2009142880P 2009-01-06; US2009142885P 2009-01-06;… US14808174A 2015-0… &lt;NA&gt;         &lt;NA&gt;          US9806541B2     
##  9 FR20142036A 2014-09-12                                                                                                                                                                 US14848061A 2015-0… &lt;NA&gt;         &lt;NA&gt;          US9805606B2     
## 10 US14970643A 2015-12-16                                                                                                                                                                 US14970643A 2015-1… &lt;NA&gt;         &lt;NA&gt;          US9805598B2     
## # ... with 18,960 more rows</code></pre>
<p>We will only be working with the priority number and the application number, but as a general principle it is useful to understand the relationship between these fields which can be simply described as follows.</p>
<p>priority number &gt; application number &gt; publication number &gt; family members</p>
<p>We can get a clearer understanding of the relationship between these numbers by looking at the front page of a patent document from our dataset using the popular <a href="mailto:esp@cenet">esp@cenet</a> database. You can access this example <a href="https://worldwide.espacenet.com/publicationDetails/biblio?FT=D&amp;date=20151210&amp;DB=EPODOC&amp;locale=en_EP&amp;CC=US&amp;NR=2015357831A1&amp;KC=A1&amp;ND=4">here</a>.</p>
<p><img src="/images/priority/witricity.png" width="800px" style="display: block; margin: auto;" /></p>
<p>We can see that the front page or biblio of a patent record contains a large amount of information. It is typically this information that is used to generate patent statistics. For our purposes we can see that the priority numbers field consists of one or more priority numbers. We might expect that there would only be one priority number as the original filing for the invention. However that is often not the case as we will discuss below.</p>
<p>From the front page we can see that if we proceed up from the priority numbers the first priority number in the list exactly matches the application number on the front page. This tells us that this is the first filing for this particular application. This application is then published as US2015357831A1.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> We can clearly see the relationship we described above</p>
<p><code>priority number &gt; application number &gt; publication number</code></p>
<p>In a separate article we will address family members (patent publications that link to one or more of priority numbers) but these family members can be accessed through the INPADOC Patent Family <a href="https://worldwide.espacenet.com/publicationDetails/inpadocPatentFamily?CC=US&amp;NR=2015357831A1&amp;KC=A1&amp;FT=D&amp;ND=4&amp;date=20151210&amp;DB=EPODOC&amp;locale=en_EP">here</a> and will include our target publication.</p>
<p>For the moment however, let’s make sure we have a good understanding of priority numbers.</p>
<p>The OECD Manual on Patent Statistics describes the Priority number and the priority date as follows</p>
<blockquote>
<p>Priority number. This is the application or publication number of the priority application, if applicable. It makes it possible to identify the priority country, reconstruct patent families, etc.</p>
</blockquote>
<blockquote>
<p>Priority date. This is the first date of filing of a patent application, anywhere in the world (usually in the applicant’s domestic patent office), to protect an invention. It is the closest to the date of invention. (OECD 2009: 25)</p>
</blockquote>
<p>In practice there are other aspects to the priority number that we need to understand</p>
</div>
<div id="multiple-priority-numbers" class="section level3">
<h3>Multiple Priority Numbers</h3>
<p>As we can see in the example above this record contains multiple priority numbers when intuitively we might have assumed that one invention = one priority number. The patent system does not actually work like that and there are two reasons for this that we need to understand.</p>
<ol style="list-style-type: decimal">
<li>Patent applicants frequently file in more than one country</li>
</ol>
<p>In a simple case there is a single priority number and the application number will be identical to that priority number. We can see this in the first example from our dataset. The priority number and the application number are the same.</p>
<pre class="r"><code>library(tidyverse)
numbers[1,] %&gt;% 
  select(priority_number, application_number)</code></pre>
<pre><code>## # A tibble: 1 x 2
##   priority_number          application_number      
##   &lt;chr&gt;                    &lt;chr&gt;                   
## 1 US2016578323F 2016-09-20 US2016578323F 2016-09-20</code></pre>
<p>However, the patent system is an international system. A patent applicant may choose to file for patent rights in up to 152 contracting parties to the <a href="http://www.wipo.int/pct/en/">Patent Cooperation Treaty</a> (although applications in all member states is unusual). As the applications are submitted in multiple countries additional priority numbers will appear in the record. An example of this is provided below.</p>
<p><img src="/images/priority/japan.png" width="800px" style="display: block; margin: auto;" /></p>
<p>In this case we can see that the earliest priority number is for Japan (JP20150122335 20150617) and the second priority number is for WO (the Patent Cooperation Treaty) and incorporates the country code of the first filing JP into the new priority number (WO2016JP67809 20160615). The Patent Cooperation Treaty is the vehicle through which applicants can submit applications in multiple countries. In this case we can see that the applicant from Japan has chosen to pursue an application in the United States using the Patent Cooperation Treaty (WO) resulting in the application number US201615322008 20160615 filed in 2016 that was then published as <a href="https://worldwide.espacenet.com/publicationDetails/biblio?FT=D&amp;date=20170518&amp;DB=EPODOC&amp;locale=en_EP&amp;CC=US&amp;NR=2017137104A1&amp;KC=A1&amp;ND=4">US2017137104A1</a>.</p>
<p>From this we might be tempted to assume that the earliest priority will always appear at the front of the list of priorities. However, this assumption is not safe as we will see below where the first filing appears at the end of the list of priorities. We will be on safer ground by identifying the earliest date in the sequence.</p>
<ol start="2" style="list-style-type: decimal">
<li>Multiple earlier inventions</li>
</ol>
<p>The second situation where we observe multiple priority numbers is cases where multiple earlier applications by the same applicants contribute to the claimed invention. We can see this in the first example above. As an anecdotal observation, the presence of multiple other inventions in the priority field appears to vary by field. Thus, from personal experience, it is uncommon in agriculture, pharmaceuticals and biotechnology but appears to be more common in cases such as computing.</p>
<p>In the case of <a href="https://worldwide.espacenet.com/publicationDetails/biblio?FT=D&amp;date=20151210&amp;DB=EPODOC&amp;locale=en_EP&amp;CC=US&amp;NR=2015357831A1&amp;KC=A1&amp;ND=4">US2015357831A1</a> above we are dealing with a wireless power system for a drone with an electronic display. Close inspection of the priority numbers reveals that all the earlier priority numbers are filings in the United States with many containing the kind code P standing for Provisional application at the end of the number (e.g. US20090169240P 20090414). The Provisional application system was introduced in the United States in 1995 as a means of harmonizing its system with the wider international system.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> A provisional patent application establishes the priority date for the invention, allowing the applicant to claim priority over other claims, but has no other legal meaning until a full patent application is submitted. Provisional patent applications are not published and are not accessible for analysis.</p>
<p>To understand this a bit better we can look at the list of actual applications that appear at the start of the sequence of priority numbers.</p>
<ol style="list-style-type: decimal">
<li>US201514815121 20150731 is the priority filing for the new invention of a wireless power system for an electronic display with an impedance matching network with identical application number (US201514815121 20150731) and publication number <a href="https://worldwide.espacenet.com/publicationDetails/biblio?DB=EPODOC&amp;II=0&amp;ND=3&amp;adjacent=true&amp;locale=en_EP&amp;FT=D&amp;date=20151210&amp;CC=US&amp;NR=2015357831A1&amp;KC=A1">US2015357831A1</a>.</li>
<li><a href="https://worldwide.espacenet.com/publicationDetails/biblio?FT=D&amp;date=20151210&amp;DB=EPODOC&amp;locale=en_EP&amp;CC=US&amp;NR=2015357831A1&amp;KC=A1&amp;ND=4#">US201113267750 20111006</a> is for a Wireless Powered Television</li>
<li><a href="https://worldwide.espacenet.com/publicationDetails/biblio?FT=D&amp;date=20151210&amp;DB=EPODOC&amp;locale=en_EP&amp;CC=US&amp;NR=2015357831A1&amp;KC=A1&amp;ND=4#">US201113232868 20110914</a> is for a wireless energy distribution system.</li>
</ol>
<p>As this makes clear, the first filing for this specific invention is the priority number that matches the application number. The other applications in the list could be described as contributing inventions. That is, the specific invention is based on combinations of elements of the other inventions in the list or elaborates on specific aspects of them as a new invention. Note that if we were to start exploring the provisional applications (kind code P) we would be confronted with lists of applications that arise from those provisional applications because provisional applications are not published directly except where they become full applications. You can test that with this example <a href="https://worldwide.espacenet.com/publicationDetails/biblio?DB=EPODOC&amp;II=0&amp;ND=3&amp;adjacent=true&amp;locale=en_EP&amp;FT=D&amp;date=20151210&amp;CC=US&amp;NR=2015357831A1&amp;KC=A1#">US20100411490P</a>.</p>
<p>What does this mean in terms of counting first filings or priority documents? If we choose the <em>earliest filing</em> in the list <a href="https://worldwide.espacenet.com/searchResults?PL=true&amp;ND=5&amp;DB=EPODOC&amp;query=PR%3DUS20090169240P">US20090169240P 20090414</a> we will be choosing a provisional application for a contributing invention at the base of a set of inventions.</p>
<p>So, we could:</p>
<ol style="list-style-type: decimal">
<li>Choose this filing as the earliest filing bearing in mind it is for a contributing invention rather than the invention itself, or</li>
<li>We could choose the priority number where the application number is identical as the first filing of the application claiming a wireless power system for an electronic display (US201514815121 20150731).</li>
</ol>
<p><!--- in the case of an non provisional application based on a provisinal application the nonprovisional application will enjoy the effective filing date of the provisional application----></p>
<p>If our aim is to simply to identify the earliest filing then we would choose option one. This will take us to the earliest in the set of filings but that may be some years before the research and development leading to the specific invention. This is the easiest option because in effect all we have to do is identify the earliest priority date in a set.</p>
<p>However, if we choose option 2 we will identify the date that is closest to the investment in research and development leading to the specific invention. At first sight this is more attractive in using patent data as an indicator for technology trends but it is significantly more challenging in terms of methodology.</p>
<p>As this helps to clarify, when dealing with patent counts we are often dealing with <em>many to many relationships</em>. The application number, as we have just seen, is central to our ability to navigate these relationships and serves as the key field in patent databases such as the EPO World Patent Statistical Database (PATSTAT). The reason for this is that where an application number is identical to a priority number in a set we know it is the first filing. Any other priority numbers either reflect the filing route (national to regional to international) or are for contributing inventions. Any other application numbers or publications are members of the family linked to that first filing. We will address this in more detail in an article on family members.</p>
<p>In this article our aim will be to map priority filings by identifying the earliest priority dates in the set of priorities linked to an application. In the process we will explore some of the issues that need to be considered when counting patents by priority.</p>
</div>
<div id="summary" class="section level3">
<h3>Summary</h3>
<p>We now have enough background to begin counting first filings using the priority number. In summary:</p>
<ol style="list-style-type: decimal">
<li>The priority number records the first filing of a patent application anywhere in the world;</li>
<li>Where a priority document is the first filing the application number will be identical to the priority number;</li>
<li>A single application may contain multiple priority numbers that reflect:</li>
</ol>
<ul>
<li>The history of the filing route of applications with the earliest priority date being the first filing;</li>
<li>Multiple contributing inventions where the first filing of the target application will be the priority number that is identical to the application number and the earliest priority will be the base of a set of inventions or patent family.</li>
</ul>
</div>
<div id="counting-priority-numbers" class="section level2">
<h2>Counting Priority Numbers</h2>
<p>We are now in a position to begin working on counting first filings based on the identification of the earliest priority dates for a set of applications.</p>
<p>To approach this we will need to start by asking two questions:</p>
<ol style="list-style-type: decimal">
<li>Does our dataset contain duplicate records? If so we will over count.</li>
<li>Does our dataset contain missing data? If so, what is the appropriate way to deal with that?</li>
</ol>
<div id="dealing-with-duplicates" class="section level3">
<h3>Dealing with duplicates</h3>
<p>We will deal with the question of duplicate data first. This is extremely common with patent data. Duplication arises because a single patent application may be published and republished multiple times (as an application, grant or correction). Duplication is inherent to the system as a global system. Duplication is also prominent when working with patent data because the most common way of retrieving data from a patent database is through publication numbers. Put simply, we can’t read a document that hasn’t been published and so when querying databases it is publications that we see. It is also publications that are downloaded from databases. For some databases, such as Derwent Innovation, there does not appear to be a way to deduplicate the data prior to export and so this has to be handled after export. In other cases, such as the free Lens patent databases or other commercial databases, it is possible to reduce the data onto a single filing. However, the criteria that are applied when deduplicating at source are often unclear - and may vary between databases - so this can impact on your ability to understand the data. If in doubt choose the rawest form and work from there.</p>
<p>Let’s look at the data again to gain an understanding of the duplication issue. We will arrange the data by the application number for reasons that will become clear in a moment. If you are following this in R then note that <code>arrange()</code> puts the application number in alphabetical order. <code>select()</code> using <code>-</code> drops the columns we don’t want to see right now. Because the duplicates can be difficult to spot I have selected a few rows to make this clear.</p>
<pre class="r"><code>numbers %&gt;% 
  arrange(application_number) %&gt;% 
  select(-family_first, -family_number, -publication_number) %&gt;% 
  .[53:60,]</code></pre>
<pre><code>## # A tibble: 8 x 2
##   priority_number                                                                                     application_number      
##   &lt;chr&gt;                                                                                               &lt;chr&gt;                   
## 1 EP1980400905A 1980-06-19; FR197916840A 1979-06-29                                                   EP1980400905A 1980-06-19
## 2 EP1980400905A 1980-06-19; FR197916840A 1979-06-29                                                   EP1980400905A 1980-06-19
## 3 SE19799920A 1979-11-30                                                                              EP1980850181A 1980-11-28
## 4 SE19799920A 1979-11-30                                                                              EP1980850181A 1980-11-28
## 5 JP1979145870A 1979-11-09; JP1979145871A 1979-11-09; JP19804902A 1980-01-18; JP198074817A 1980-06-02 EP1980902127A 1980-11-06
## 6 JP1979145870A 1979-11-09; JP1979145871A 1979-11-09; JP19804902A 1980-01-18; JP198074817A 1980-06-02 EP1980902127A 1980-11-06
## 7 US1979105606A 1979-12-20                                                                            EP1981900248A 1980-12-17
## 8 US1979105606A 1979-12-20                                                                            EP1981900248A 1980-12-17</code></pre>
<p>There are two things we need to note in this view.</p>
<p>First, some of our data is concatenated (joined) with <code>;</code> as the separator. Second, and more importantly for the moment, we can see that we seem to have duplicate application numbers e.g. EP1980400905A in the first and second rows and then onwards.</p>
<p>The reason that we have duplicates in the data is that a patent application may be published multiple times (for example as an application and as a grant or with corrections etc.). So, in the data above we can see that EP1980400905A 1980-06-19 has been published as EP22391A1 and EP22391B1 with the two letter <code>kind codes</code> at the end of the publication number representing the first publication of the application (A1) and kind code B1 representing the first publication of a patent grant.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<pre class="r"><code>numbers %&gt;% 
  arrange(application_number) %&gt;% 
  select(-family_first, -family_number, - priority_number) %&gt;% 
  .[53:60,]</code></pre>
<pre><code>## # A tibble: 8 x 2
##   application_number       publication_number
##   &lt;chr&gt;                    &lt;chr&gt;             
## 1 EP1980400905A 1980-06-19 EP22391B1         
## 2 EP1980400905A 1980-06-19 EP22391A1         
## 3 EP1980850181A 1980-11-28 EP30219B1         
## 4 EP1980850181A 1980-11-28 EP30219A1         
## 5 EP1980902127A 1980-11-06 EP39740B1         
## 6 EP1980902127A 1980-11-06 EP39740A1         
## 7 EP1981900248A 1980-12-17 EP42004B1         
## 8 EP1981900248A 1980-12-17 EP42004A1</code></pre>
<p>Where a document is republished the application number will be duplicated. This means that we will also end up with duplicated priority numbers and we will over count. Removing duplicate records is the key requirement for accurate counts of patent data.</p>
<p>So, lets remove the duplicate application numbers first. To do that we will use a simple piece of R code from the <code>dplyr</code> package (you loaded it with the tidyverse) to add a new column that identifies the duplicated records. We will create a new column called duplicated using <code>mutate()</code> which adds columns. We will add the duplicated column by applying the R function <code>duplicated()</code> to the application_number column. What this does is to loop over the column and identifies the first instance of the application_number and then duplicates of the application_number. The first instance of the application_number will be marked as FALSE (not duplicated) and the others as TRUE (duplicated). We will then use the <code>filter()</code> function from <code>dplyr</code> to limit the data to our non-duplicated numbers <code>== FALSE</code>.</p>
<p>A couple of other things to note is that we will put this in a new table called numbers unique by using the assignment <code>&lt;-</code> operator. We also use the pipe <code>%&gt;%</code> operator which takes what it finds on the left hand side and passes it into the right hand side. So, we see that <code>numbers %&gt;% mutate()</code> passes the numbers table or data.frame from the left hand side into <code>mutate()</code> to create a new column based on the contents of the call to mutate. It’s simple and logical when you become familiar with it. At the end of this chunk of code we will limit the data to just the priority_number and the application_number which we will be using as a key.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> The <code>select()</code> function from <code>dplyr</code> will only select those columns that we name inside it and will drop the others. These three functions: <code>select()</code> for columns, <code>filter()</code> for rows, and <code>mutate()</code> to add new values connected with the pipe <code>%&gt;%</code> represent the building blocks for almost everything you need to do with patent data in R. The rest such as <code>duplicated()</code> help you to perform particular operations and we will go into more detail with that below.</p>
<pre class="r"><code>numbers_unique &lt;- numbers %&gt;%
  mutate(duplicated = duplicated(application_number)) %&gt;% 
  filter(duplicated == &quot;FALSE&quot;) %&gt;% 
  select(priority_number, application_number, publication_number)

nrow(numbers_unique) # count the rows</code></pre>
<pre><code>## [1] 15776</code></pre>
<p>This reduces our original 18,970 records to 15,776 records. We now want to take a look at our data to check for missingness.</p>
</div>
<div id="missing-data" class="section level3">
<h3>Missing Data</h3>
<p>We will be counting and graphing the priority numbers. So we will want to check that all of our records have a priority number. We will also be using dates to graph the data and it will be a very good idea to check the dates at this stage. The reason for this is that strange things can happen with patent dates and this is often linked to missingness in the data as we will see in a moment.</p>
<p>In R missing data is represented by NA for Not Available. Working with NA data can be awkward and a source of considerable frustration because NA is not a value, it is the absence of a value. We can solve this by adding a column using <code>mutate()</code> that will test the priority number field for NA values <code>is.na()</code>. We will then apply a filter to allow us to see the top results where the value for <code>is.na()</code> is TRUE. To see all the data add <code>%&gt;% View()</code> to the end.</p>
<pre class="r"><code>numbers_unique %&gt;% 
  mutate(missing_priority = is.na(priority_number)) %&gt;% 
  filter(missing_priority == &quot;TRUE&quot;)</code></pre>
<pre><code>## # A tibble: 96 x 4
##    priority_number application_number    publication_number missing_priority
##    &lt;chr&gt;           &lt;chr&gt;                 &lt;chr&gt;              &lt;lgl&gt;           
##  1 &lt;NA&gt;            USD502486A 0001-01-01 US502486A          TRUE            
##  2 &lt;NA&gt;            USD500197A 0001-01-01 US500197A          TRUE            
##  3 &lt;NA&gt;            USD499490A 0001-01-01 US499490A          TRUE            
##  4 &lt;NA&gt;            USD497518A 0001-01-01 US497518A          TRUE            
##  5 &lt;NA&gt;            USD565353A 0001-01-01 US565353A          TRUE            
##  6 &lt;NA&gt;            USD474115A 0001-01-01 US474115A          TRUE            
##  7 &lt;NA&gt;            USD459287A 0001-01-01 US459287A          TRUE            
##  8 &lt;NA&gt;            USD540479A 0001-01-01 US540479A          TRUE            
##  9 &lt;NA&gt;            USD522772A 0001-01-01 US522772A          TRUE            
## 10 &lt;NA&gt;            USD593712A 0001-01-01 US593712A          TRUE            
## # ... with 86 more rows</code></pre>
<p>The first thing we notice about this data is that the dates for the records are 0001-01-01. This type of device (along with 999999) is often used to denote the absence of a date. In this case if we look up some of these cases we will discover that they are very old records. For example <a href="https://worldwide.espacenet.com/publicationDetails/biblio?DB=EPODOC&amp;II=0&amp;ND=3&amp;adjacent=true&amp;locale=en_EP&amp;FT=D&amp;date=18850728&amp;CC=US&amp;NR=322982A&amp;KC=A">US322982A</a> dates to 1885. The Paris Convention did not enter into force in the United States until May 1887 and it is unclear when exactly the USPTO started using the system, so it is not surprising that these documents lack priority numbers.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> If we continue to keep these records we will see an artificial spike of activity somewhere at the start of our graph. In this case we can safely drop these records using the handy <code>drop_na()</code> function from <code>dplyr</code>. We will simply overwrite the existing table and specify the priority number as the column where we will drop the rows with NA values.</p>
<pre class="r"><code>numbers_unique &lt;- numbers_unique %&gt;% 
  drop_na(priority_number) %&gt;% 
  select(-publication_number)

nrow(numbers_unique)</code></pre>
<pre><code>## [1] 15680</code></pre>
<p>We have now reduced our dataset to 15,680 unique application numbers. Note that you may want to also use this type of <code>test, investigate, decide</code> approach with other fields but it is always a good idea to note down the decisions that you make when doing so, otherwise what Hadley Wickham has called “future you” will have no idea and your audience will also have no clue.</p>
<p>When working with this kind of data it is useful to create a reference number or even a full table that allows you to work out whether any operations you run afterwards are working correctly. In this case we now know that we have 15,680 application numbers. In the next section we will be working out the earliest priority dates for each of these documents. We therefore need to ensure that we end up with 15,680 application numbers. We will create a reference number called target from the number of rows <code>nrow()</code> in the dataset before we go any further. This can help us work out what is going wrong if we end up with different numbers at the end. For more complex cases try creating a copy of the full table that you can use to work out what is getting lost or not counting correctly.</p>
<pre class="r"><code>target &lt;- nrow(numbers_unique)
target</code></pre>
<pre><code>## [1] 15680</code></pre>
<p>We now know that we have no missing priority dates so we can proceed to wrangling or processing the priority numbers.</p>
</div>
<div id="wrangling-the-priority-numbers" class="section level3">
<h3>Wrangling the Priority Numbers</h3>
<p>We can’t count concatenated data properly, so our next step is to separate out the concatenated priority numbers into individual rows. We will also want to extract the dates from the priority numbers that we will use later on to create a graph. We will do this in one go. In the first step we will use <code>separate_rows()</code> from <code>tidyr</code> to break the priority numbers onto individual rows using <code>;</code> as the separator. We then use <code>separate()</code> to separate out the priority number and the date component. This will create two new columns called priority and priority_date. We will then apply two functions to these columns using <code>mutate()</code>. The first will convert the priority date to date format in R. The second will trim any white space that appears at the front or end of the priority number field from the earlier separation. Trimming white space is an extremely important step. For example <code>US1234</code> and the same number with a white space at the front or rear _US1234, where <code>_</code> stands for the space, will be treated as a distinct number and will not count correctly. Trimming white space is a fundamental task when counting patent data and the single most common reason that your counts will not be correct at the end of all your hard work!</p>
<p>As a final step in data preparation we will add some additional features. We will identify the US provisional applications and we will count the number of priorities associated with an application. We will also extract the two letter country codes at the beginning of the priority and application number fields as they may assist us later and will be used in counts. Note that the count of priority numbers in <code>n</code> reveals the total number of priorities associated with an application number. We will not use all of these fields for this type of count but they are useful to assist with understanding the data as we move along.</p>
<pre class="r"><code>numbers_unique &lt;- numbers_unique %&gt;% 
  separate_rows(priority_number, sep = &quot;;&quot;) %&gt;% 
  mutate(priority_number = str_trim(priority_number, side = &quot;both&quot;)) %&gt;%
  separate(priority_number, into = c(&quot;priority&quot;, &quot;priority_date&quot;), sep = &quot; &quot;, remove = FALSE) %&gt;% 
  mutate(priority_date = lubridate::ymd(priority_date)) %&gt;% 
  mutate(priority = str_trim(priority, side = &quot;both&quot;)) %&gt;%
  mutate(priority_number = str_trim(priority_number, side = &quot;both&quot;)) %&gt;% 
  mutate(provisional = str_detect(.$priority_number, &quot;[[:digit:]]P &quot;)) %&gt;%
  group_by(application_number) %&gt;%
  mutate(priority_count = seq_along(1)) %&gt;%
  add_tally(wt = priority_count) %&gt;% 
  ungroup() %&gt;% 
  mutate(priority_country = str_sub(.$priority_number, 1,2)) %&gt;% 
  mutate(application_country = str_sub(.$application_number, 1,2)) %&gt;%
  select(-priority_count, -priority) # drop temporary count and unused column

numbers_unique</code></pre>
<pre><code>## # A tibble: 68,361 x 7
##    priority_number          priority_date application_number       provisional     n priority_country application_country
##    &lt;chr&gt;                    &lt;date&gt;        &lt;chr&gt;                    &lt;lgl&gt;       &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;              
##  1 US2016578323F 2016-09-20 2016-09-20    US2016578323F 2016-09-20 FALSE           1 US               US                 
##  2 US14954632A 2015-11-30   2015-11-30    US14954632A 2015-11-30   FALSE           1 US               US                 
##  3 US15360203A 2016-11-23   2016-11-23    US15360203A 2016-11-23   FALSE           1 US               US                 
##  4 US62203383P 2015-08-10   2015-08-10    US15454805A 2017-03-09   TRUE            2 US               US                 
##  5 US62314047P 2016-03-28   2016-03-28    US15454805A 2017-03-09   TRUE            2 US               US                 
##  6 US62200764P 2015-08-04   2015-08-04    US15263985A 2016-09-13   TRUE            2 US               US                 
##  7 US62314042P 2016-03-28   2016-03-28    US15263985A 2016-09-13   TRUE            2 US               US                 
##  8 KR201528901A 2015-03-02  2015-03-02    US15057264A 2016-03-01   FALSE           1 KR               US                 
##  9 US15217944A 2016-07-22   2016-07-22    US15217944A 2016-07-22   FALSE           3 US               US                 
## 10 US2015196885P 2015-07-24 2015-07-24    US15217944A 2016-07-22   TRUE            3 US               US                 
## # ... with 68,351 more rows</code></pre>
<p>Let’s quickly review what we just did in plain language. We separated each priority number onto its own row using the semicolon as the separator then we split off the priority number and the date and reformatted the date before finally trimming the white space around the numbers in the priority column. A couple of points to note here: in the call to separate we specified the separator or <code>sep</code> as a space, we opted to keep the original column with <code>remove = FALSE</code> (the default is true and removes the column). We then added a simple count because we know the number of application numbers are duplicated to the number of priorities and then grouped the applications to add a count of the total priorities per application with <code>add_tally</code>. We ungrouped the table and then extracted the priority country and application country. Ungrouping is important, but hard to remember, because if we do not ungroup the data then any calculation we apply will be applied by group. This will normally cause unexpected results or the calculation simply won’t work.</p>
<p>When preparing data in this way one of the signs that there are unresolved issues with your data is that you will receive warnings about missing or extra pieces of data when you use <code>separate()</code>. If you see these messages go back and inspect your data. It can mean that there are NA values in the column you are separating or it can mean that you have extra spaces (so there will be too many pieces) or something else is present in the data. Issues with white space are common culprits with patent data (following separation) and this is one of the reasons that there are two calls to trim white space with <code>str_trim()</code> as a security blanket to avoid later problems.</p>
<p>To make this clearer lets just try and run separate on our original concatenated data using the space as the separator.</p>
<pre class="r"><code>numbers %&gt;% 
  separate(priority_number, into = c(&quot;one&quot;, &quot;two&quot;), sep = &quot; &quot;)</code></pre>
<pre><code>## Warning: Expected 2 pieces. Additional pieces discarded in 10937 rows [4, 5, 7, 8, 11, 21, 22, 32, 33, 34, 37, 39, 40, 41, 42, 43, 44, 45, 48, 49, ...].</code></pre>
<pre><code>## # A tibble: 18,970 x 6
##    one           two         application_number       family_first family_number publication_number
##    &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;                    &lt;chr&gt;        &lt;chr&gt;         &lt;chr&gt;             
##  1 US2016578323F 2016-09-20  US2016578323F 2016-09-20 &lt;NA&gt;         &lt;NA&gt;          USD801224S1       
##  2 US14954632A   2015-11-30  US14954632A 2015-11-30   &lt;NA&gt;         &lt;NA&gt;          US9807866B2       
##  3 US15360203A   2016-11-23  US15360203A 2016-11-23   &lt;NA&gt;         &lt;NA&gt;          US9807726B1       
##  4 US62203383P   2015-08-10; US15454805A 2017-03-09   &lt;NA&gt;         &lt;NA&gt;          US9807625B2       
##  5 US62200764P   2015-08-04; US15263985A 2016-09-13   &lt;NA&gt;         &lt;NA&gt;          US9807619B2       
##  6 KR201528901A  2015-03-02  US15057264A 2016-03-01   &lt;NA&gt;         &lt;NA&gt;          US9807364B2       
##  7 US15217944A   2016-07-22; US15217944A 2016-07-22   &lt;NA&gt;         &lt;NA&gt;          US9806846B2       
##  8 US2008100721P 2008-09-27; US14808174A 2015-07-24   &lt;NA&gt;         &lt;NA&gt;          US9806541B2       
##  9 FR20142036A   2014-09-12  US14848061A 2015-09-08   &lt;NA&gt;         &lt;NA&gt;          US9805606B2       
## 10 US14970643A   2015-12-16  US14970643A 2015-12-16   &lt;NA&gt;         &lt;NA&gt;          US9805598B2       
## # ... with 18,960 more rows</code></pre>
<p>We immediately get a warning about extra pieces in over 10,000 rows signifying that we need to go back and pay more attention to our data. In other cases you will not always be concerned about this, although it is an extremely good idea to be clear about why you are not concerned, and you can deal with extra data by specifying <code>extra = &quot;merge&quot;</code>. For fun let’s try that.</p>
<pre class="r"><code>numbers %&gt;% 
  separate(priority_number, into = c(&quot;one&quot;, &quot;two&quot;), sep = &quot; &quot;, extra = &quot;merge&quot;) %&gt;% 
  select(one, two)</code></pre>
<pre><code>## # A tibble: 18,970 x 2
##    one           two                                                                                                                                                                                                                                     
##    &lt;chr&gt;         &lt;chr&gt;                                                                                                                                                                                                                                   
##  1 US2016578323F 2016-09-20                                                                                                                                                                                                                              
##  2 US14954632A   2015-11-30                                                                                                                                                                                                                              
##  3 US15360203A   2016-11-23                                                                                                                                                                                                                              
##  4 US62203383P   2015-08-10; US62314047P 2016-03-28                                                                                                                                                                                                      
##  5 US62200764P   2015-08-04; US62314042P 2016-03-28                                                                                                                                                                                                      
##  6 KR201528901A  2015-03-02                                                                                                                                                                                                                              
##  7 US15217944A   2016-07-22; US2015196885P 2015-07-24; US62196885P 2015-07-24                                                                                                                                                                            
##  8 US2008100721P 2008-09-27; US2008108743P 2008-10-27; US2008121159P 2008-12-09; US2009142796P 2009-01-06; US2009142818P 2009-01-06; US2009142880P 2009-01-06; US2009142885P 2009-01-06; US2009142887P 2009-01-06; US2009142889P 2009-01-06; US200914297…
##  9 FR20142036A   2014-09-12                                                                                                                                                                                                                              
## 10 US14970643A   2015-12-16                                                                                                                                                                                                                              
## # ... with 18,960 more rows</code></pre>
<p>As we would expect from using the space as a separator, the function is showing us the number in the first column and the date in the second but is then tacking on the rest of the data in cases with multiple priority numbers. Warnings and arguments such as <code>extra = &quot;merge&quot;</code> can help you get to grips with the issues in your data.</p>
</div>
<div id="identifying-the-earliest-priority-date" class="section level3">
<h3>Identifying the earliest priority date</h3>
<p>In the discussion of the options identified above we noted that we could:</p>
<ol style="list-style-type: decimal">
<li>Identify the earliest priority document</li>
<li>Identify the priority that is closest to the specific invention</li>
</ol>
<p>Here we will focus on simply identifying the earliest priority. We can do this in a straight forward way by grouping our application numbers and then using the <code>rank()</code> function inside a call to <code>mutate()</code> to rank the dates from 1 to x. A key point here is that the default ranking method for the rank function is actually average. We therefore need to specify <code>ties.method = &quot;first&quot;</code> to get what we want. We then ungroup our table and filter to the earliest priority date using <code>filing_order == 1</code>.</p>
<pre class="r"><code>earliest &lt;- numbers_unique %&gt;% 
  group_by(application_number) %&gt;% 
  mutate(filing_order = rank(priority_date, ties.method = &quot;first&quot;)) %&gt;%
  ungroup() %&gt;% 
  filter(filing_order == 1)

earliest</code></pre>
<pre><code>## # A tibble: 15,680 x 8
##    priority_number          priority_date application_number       provisional     n priority_country application_country filing_order
##    &lt;chr&gt;                    &lt;date&gt;        &lt;chr&gt;                    &lt;lgl&gt;       &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;                      &lt;int&gt;
##  1 US2016578323F 2016-09-20 2016-09-20    US2016578323F 2016-09-20 FALSE           1 US               US                             1
##  2 US14954632A 2015-11-30   2015-11-30    US14954632A 2015-11-30   FALSE           1 US               US                             1
##  3 US15360203A 2016-11-23   2016-11-23    US15360203A 2016-11-23   FALSE           1 US               US                             1
##  4 US62203383P 2015-08-10   2015-08-10    US15454805A 2017-03-09   TRUE            2 US               US                             1
##  5 US62200764P 2015-08-04   2015-08-04    US15263985A 2016-09-13   TRUE            2 US               US                             1
##  6 KR201528901A 2015-03-02  2015-03-02    US15057264A 2016-03-01   FALSE           1 KR               US                             1
##  7 US2015196885P 2015-07-24 2015-07-24    US15217944A 2016-07-22   TRUE            3 US               US                             1
##  8 US2008100721P 2008-09-27 2008-09-27    US14808174A 2015-07-24   TRUE           22 US               US                             1
##  9 FR20142036A 2014-09-12   2014-09-12    US14848061A 2015-09-08   FALSE           1 FR               US                             1
## 10 US14970643A 2015-12-16   2015-12-16    US14970643A 2015-12-16   FALSE           1 US               US                             1
## # ... with 15,670 more rows</code></pre>
<p>We now have a data frame that identifies the earliest priority numbers in a set. The 15,680 records corresponds match our target of 15,680 application numbers and so all is good.</p>
<p>The final step with this data is to remember that this dataset is based on unique <em>application numbers</em> and not unique priority numbers. In practice, some of the application numbers in our set will share priority numbers with other applications and will be follow on filings. We therefore need to identify duplicates in the priority numbers and deduplicate to unique priority numbers.</p>
<pre class="r"><code>earliest_unique &lt;- earliest %&gt;% 
  mutate(duplicate_priority = duplicated(.$priority_number)) %&gt;% 
  filter(duplicate_priority == &quot;FALSE&quot;)</code></pre>
<p>This reduces our dataset to a total of 9,366 priority numbers. That is, these priority numbers are the earliest filings giving rise to the 15,680 applications in the drones dataset.</p>
<p>By pursuing this option we have arrived at the absolute earliest dateline in this dataset on drones through a process of deduplication. However, as the numbers suggest we have also taken out a lot of potentially useful information. At this point it is important to bear in mind that this type of calculation can only be used to graph baseline first filings. We will look at this in further depth in a follow on article.</p>
<p>Let’s quickly graph this data. Here we are using the popular R graphing package ggplot2 to draw quick graphs of the data. To learn more about using <code>ggplot2</code> try the excellent <a href="http://www.cookbook-r.com/Graphs/">R Graphics Cookbook by Winston Chang</a> which is available in open access form online. A step by step walk through on using ggplot2 to visualise patent data is available in this <a href="https://www.pauloldham.net/graphing-patent-data-with-ggplot2-part2/">article</a>. If you prefer using Excel or Tableau then write the file to a .csv and then open it in your tool of choice. You can do this simply with the following line of code.</p>
<pre class="r"><code>readr::write_csv(earliest_unique, &quot;earliest_unique.csv&quot;)</code></pre>
<p>ggplot2 is quite a lot more involved than working with Tableau, Excel or other tools but provides a powerful way to control graphing. Let’s take a quick look at the data.</p>
<p><img src="/post/2018-05-11-counting-patent-first-filings_files/figure-html/unnamed-chunk-6-1.png" width="800px" style="display: block; margin: auto;" /></p>
<p>Note that graphs of priority data display a characteristic data cliff the closer that we move towards the present. This reflects the fact that patent applications are normally published at least 24 months after they were originally filed. This data cliff can easily mislead an audience into believing that interest in a technology has suddenly collapsed when in reality we are missing or only have partial data for the period. It is therefore important to pull the year range back to accommodate this. Depending on your data it is sensible to pull back the year by at least two years and possibly three years.</p>
<pre class="r"><code>earliest_unique %&gt;% 
  select(-n) %&gt;% 
  mutate(year = lubridate::year(priority_date)) %&gt;% 
  filter(year &gt;= 1990 &amp; year &lt;= 2015) %&gt;% 
  group_by(year) %&gt;%
  tally() %&gt;%  
  ggplot(., aes(x = year, y = n)) +
  geom_line() +
  labs(title = &quot;Trends in First Filings of Patent Applications for Drone Technology&quot;, x = &quot;priority year&quot;, y = &quot;first filings&quot;)</code></pre>
<p><img src="/post/2018-05-11-counting-patent-first-filings_files/figure-html/unnamed-chunk-7-1.png" width="800px" style="display: block; margin: auto;" /></p>
<p>Note the speed bump in the data around 2008 that is likely to reflect the impact of the financial crisis with filings relating to drone technology before accelerating rapidly in recent years.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<p>In this dataset we can also gain an insight into the countries driving this trend by ranking them in a bar graph for the same period.</p>
<pre class="r"><code>library(ggthemes)
earliest_unique %&gt;%
  select(-n) %&gt;% 
  filter(priority_date &gt;= &quot;1990-01-01&quot; &amp; priority_date &lt;= &quot;2017-12-01&quot;) %&gt;% 
  group_by(priority_country) %&gt;% 
  tally(sort = TRUE) %&gt;% 
  filter(n &gt; 100) %&gt;% 
  ggplot(aes(x = reorder(priority_country, n), y = n, fill = priority_country)) +
  geom_bar(stat = &quot;identity&quot;) +
  coord_flip() +
  labs(title = &quot;First Filings by Priority Country&quot;, x = &quot;Priority Country&quot;, y = &quot;First Filings&quot;) +
  geom_text(aes(y = n, label = n), size = 3, hjust = -0.1) +
  theme_igray() +
  scale_fill_tableau(&quot;tableau20&quot;) +
  theme(legend.position = &quot;none&quot;)</code></pre>
<p><img src="/post/2018-05-11-counting-patent-first-filings_files/figure-html/echo-1.png" width="800px" style="display: block; margin: auto;" /></p>
<p>Note here that the United States emerges first in the top 5 followed by Japan, France, Korea and the Patent Cooperation Treaty (WO). It is important to bear in mind here that WO records will typically be filed through national offices, although no priority number will be present, as we can see in the references to country codes inside the WO priority documents.</p>
<pre class="r"><code>earliest_unique %&gt;% 
  filter(priority_country == &quot;WO&quot;) %&gt;% 
  select(priority_number)</code></pre>
<pre><code>## # A tibble: 286 x 1
##    priority_number          
##    &lt;chr&gt;                    
##  1 WO2016US65141A 2016-12-06
##  2 WO2015CN79094A 2015-05-15
##  3 WO2014CN86739A 2014-09-17
##  4 WO2015EP76803A 2015-11-17
##  5 WO2014EP72175A 2014-10-16
##  6 WO2013US65291A 2013-10-16
##  7 WO2014PL50044A 2014-07-24
##  8 WO2014US21626A 2014-03-07
##  9 WO2013US46840A 2013-06-20
## 10 WO2012US69292A 2012-12-12
## # ... with 276 more rows</code></pre>
<p>We can summarise this data by extracting the country codes in the middle of the WO numbers. This suggests that the country where the WO application was submitted was the US followed by China (CN) and so on. The reference to the IB in these numbers are for so called PCT direct filings that are filed directly with WIPO as the International Bureau (IB) for the Patent Cooperation Treaty.</p>
<pre class="r"><code>earliest_unique %&gt;% 
  filter(priority_country == &quot;WO&quot;) %&gt;% 
  select(priority_number) %&gt;% 
  mutate(wo_source = str_sub(.$priority_number, 7,8)) %&gt;% 
  count(wo_source, sort = TRUE)</code></pre>
<pre><code>## # A tibble: 25 x 2
##    wo_source     n
##    &lt;chr&gt;     &lt;int&gt;
##  1 US           71
##  2 CN           46
##  3 EP           43
##  4 JP           43
##  5 IB           19
##  6 KR           14
##  7 SE           13
##  8 RU            7
##  9 FR            5
## 10 PL            5
## # ... with 15 more rows</code></pre>
<p>As such, for a fuller count we might consider reallocating these priority numbers to their respective national country offices.</p>
<p>Note that we cannot go much further with this data to chart application countries accurately because we have deduplicated the priority numbers that would provide access to the application country data. A superior approach would be to create a temporary field for the unique priorities that allows the linked application countries to be viewed.</p>
</div>
<div id="bringing-together-the-code" class="section level3">
<h3>Bringing together the code</h3>
<p>To finish off this discussion let’s briefly summarise the code required to reduce the dataset to the early priority filings. Here we will present the code in one go following some pruning to remove extra elements that we did not use to generate this calculation.</p>
<pre class="r"><code>earliest_priority &lt;- numbers %&gt;%
  mutate(duplicated = duplicated(application_number)) %&gt;% 
  filter(duplicated == &quot;FALSE&quot;) %&gt;% 
  select(priority_number, application_number, publication_number) %&gt;% 
  drop_na(priority_number) %&gt;% 
  separate_rows(priority_number, sep = &quot;;&quot;) %&gt;% 
  mutate(priority_number = str_trim(priority_number, side = &quot;both&quot;)) %&gt;%
  separate(priority_number, into = c(&quot;priority&quot;, &quot;priority_date&quot;), sep = &quot; &quot;, remove = FALSE) %&gt;% 
  mutate(priority_date = lubridate::ymd(priority_date)) %&gt;% 
  mutate(priority_number = str_trim(priority_number, side = &quot;both&quot;)) %&gt;% 
  mutate(priority_country = str_sub(.$priority_number, 1,2)) %&gt;% 
  group_by(application_number) %&gt;% 
  mutate(filing_order = rank(priority_date, ties.method = &quot;first&quot;)) %&gt;% 
  ungroup() %&gt;% 
  filter(filing_order == 1) %&gt;% 
  mutate(duplicate_priority = duplicated(.$priority_number)) %&gt;% 
  filter(duplicate_priority == &quot;FALSE&quot;) %&gt;% 
  select(-priority)</code></pre>
<p>Calculating the earliest priority from the moment of import involved 18 lines of code focusing on using <code>mutate(), filter(), select(), drop_na(), separate_rows(), group_by()</code>, and <code>ungroup()</code>. Inside the <code>mutate()</code> function we created new columns to test for duplicates using <code>duplicated()</code>, we trimmed white space with <code>str_trim()</code>, extracted data with <code>str_sub()</code> and ranked data with <code>rank()</code>. As this makes clear R functions from the tidyverse provide building blocks that can be chained together in an easy to read way to transform data into a desired result. For this reason we advocate a tidy approach to patent analytics with R.</p>
<p>One of the most important features of R as a functional programming language is that we can wrap this code (a collection of instructions to functions) into a single function. We will call it extract priority. This code basically reproduces that above but with some additional decoration to address something called <a href="https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html">tidy evaluation</a> in R. Tidy evaluation is intellectually challenging and will not be addressed here.<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>.</p>
<pre class="r"><code>extract_priority &lt;- function(data = NULL, priority_number = NULL, key = NULL){
  x &lt;- data %&gt;%
    select(!!priority_number, !!key) %&gt;%
    mutate(duplicated = duplicated(.[[!!key]])) %&gt;%
    filter(duplicated == FALSE) %&gt;%
    drop_na(!!priority_number) %&gt;%
    separate_rows(!!priority_number, sep = &quot;;&quot;) %&gt;%
    mutate(!!priority_number := str_trim(.[[!!priority_number]], side = &quot;both&quot;)) %&gt;%
    separate(!!priority_number, into = c(&quot;priority&quot;, &quot;priority_date&quot;), sep = &quot; &quot;, remove = FALSE) %&gt;%
    mutate(priority_date = lubridate::ymd(priority_date)) %&gt;%
    mutate(!!key := str_trim(.[[!!key]], side = &quot;both&quot;)) %&gt;%
    mutate(priority_country = str_sub(.[[!!priority_number]], 1,2)) %&gt;% 
    group_by(!!!rlang::syms(key)) %&gt;% 
    mutate(filing_order = rank(priority_date, ties.method = &quot;first&quot;)) %&gt;% 
    ungroup() %&gt;% 
    filter(filing_order == 1) %&gt;%
    mutate(duplicate_priority = duplicated(.[[!!priority_number]])) %&gt;% 
    filter(duplicate_priority == &quot;FALSE&quot;) %&gt;% 
    select(-priority, -duplicated, -filing_order, -duplicate_priority)
}</code></pre>
<p>This function takes three arguments. Data is a dataset, the priority number is the field that contains the raw priority number data and the key is the field that is used for grouping (assumed to be the application number).</p>
<p>We can test this as follows:</p>
<pre class="r"><code>results &lt;- extract_priority(data = numbers, priority_number = &quot;priority_number&quot;, key = &quot;application_number&quot;)
results</code></pre>
<pre><code>## # A tibble: 9,366 x 4
##    priority_number          priority_date application_number       priority_country
##    &lt;chr&gt;                    &lt;date&gt;        &lt;chr&gt;                    &lt;chr&gt;           
##  1 US2016578323F 2016-09-20 2016-09-20    US2016578323F 2016-09-20 US              
##  2 US14954632A 2015-11-30   2015-11-30    US14954632A 2015-11-30   US              
##  3 US15360203A 2016-11-23   2016-11-23    US15360203A 2016-11-23   US              
##  4 US62203383P 2015-08-10   2015-08-10    US15454805A 2017-03-09   US              
##  5 US62200764P 2015-08-04   2015-08-04    US15263985A 2016-09-13   US              
##  6 KR201528901A 2015-03-02  2015-03-02    US15057264A 2016-03-01   KR              
##  7 US2015196885P 2015-07-24 2015-07-24    US15217944A 2016-07-22   US              
##  8 US2008100721P 2008-09-27 2008-09-27    US14808174A 2015-07-24   US              
##  9 FR20142036A 2014-09-12   2014-09-12    US14848061A 2015-09-08   FR              
## 10 US14970643A 2015-12-16   2015-12-16    US14970643A 2015-12-16   US              
## # ... with 9,356 more rows</code></pre>
<p>What this means is that where we have a dataset with a priority number field and the application number field as a key we do not need to write all the code again by hand. We may have to adjust the code… for example if the numbers contain different separators (such as ;; in the case of the Lens database) or junk such as “[” is found in a data field. However, the ability to turn code into a reusable function is the most powerful feature of programming languages such as R and a powerful reason to engage with R when working with patent data.</p>
</div>
<div id="wrap-up" class="section level3">
<h3>Wrap Up</h3>
<p>In this article we have taken a deep dive into the exploration of how to count the first filings of patent applications using information in the priority number field. We have focused on reducing a set of 18,970 patent applications to the earliest filings and arrived at 9,366 results.</p>
<p>The key take home messages from this article are that to identify the earliest priority filing we have to do the following</p>
<ol style="list-style-type: decimal">
<li>Deduplicate our data on application numbers</li>
<li>Separate the individual priority numbers onto their own row</li>
<li>Make sure we trim white space</li>
<li>Group the data on application numbers and then identify the earliest priority date for each application</li>
<li>Filter the data to the earliest priority date per application</li>
<li>Identify and remove duplicate priority numbers</li>
</ol>
<p>As discussed above, this approach focuses on a straightforward method for identifying the earliest priority filing. A more sophisticated approach would break the dataset down to identify the cases where the priority number is identical to an application number and then work through the data focusing on provisional applications. The outcome of such an exercise will not be radically different, however it would arguably be more accurate in terms of identifying the priority date closest to the date of a specific invention and working through the filing route issues. For today however this is more than enough for a first deep dive into counting patent filings by priority. If you have survived this far congratulations. You now know more than most people alive about how to count priority filings. Yay!</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>One of the most widely cited works providing an overview of the use of patents statistics is Griliches, Z 1998 Patent Statistics as Economic Indicators: A Survey, in Griliches, Z (ed.), R&amp;D and Productivity: The Econometric Evidence. Cambridge: Cambridge University Press, available at <a href="http://www.nber.org/chapters/c8351.pdf" class="uri">http://www.nber.org/chapters/c8351.pdf</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>the date field is missing in our dataset and this is common, Clarivate also adds zeros as padding so it is US20150357831A1. <a href="mailto:esp@acenet">esp@acenet</a> adds the year following the kind code as US201514815121 20150731 whereas in our Derwent Innovation data the number is US14815121 20150731<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>For details see the <a href="https://www.uspto.gov/patents-getting-started/patent-basics/types-patent-applications/provisional-application-patent">USPTO web page on Provisional Applications</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>In formal terms kind codes refer to publication types and publication levels. Their use varies over time in individual countries and across countries and should therefore be approached with a degree of caution. At major patent offices kind code A typically denotes an application and kind code B a patent grant, except for US patent documents prior to 2001 where kind code A denotes a patent grant. As this suggests, caution is needed.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>in everyday practice you may want to keep the publication number to look up records and check you are on the right track<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p><a href="http://www.wipo.int/treaties/en/ShowResults.jsp?lang=en&amp;treaty_id=2" class="uri">http://www.wipo.int/treaties/en/ShowResults.jsp?lang=en&amp;treaty_id=2</a><a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>note that the drones dataset is a training set that includes noisy terms and is not expected to fully reflect trends in drone technology<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>See <a href="https://edwinth.github.io/blog/dplyr-recipes/">Edwin Theon’s blog</a> for an introduction along with the <a href="https://www.rstudio.com/resources/webinars/tidy-eval/">RStudio video</a> and <a href="https://maraaverick.rbind.io/2017/08/tidyeval-resource-roundup/">Mara Avericks’s tidy eval resource roundup</a><a href="#fnref8">↩</a></p></li>
</ol>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-113668064-1', 'auto');
ga('send', 'pageview');
</script>

  </body>
</html>

